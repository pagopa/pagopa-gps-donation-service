parameters:
  - name: ENV
    displayName: Target Environment
    type: string
    default: dev
    values:
      - dev
      - uat
      - prod
  - name: SEMVER
    displayName: "When packing a release, define the version bump to apply. Use only buildNumber or skip for manual deployment"
    type: string
    values:
      - major
      - minor
      - patch
      - prerelease
      - skip
    default: skip
  - name: TEST
    displayName: Run tests
    type: boolean
    default: false

variables:
  NODE_VERSION: '14.19.0'
  YARN_CACHE_FOLDER: $(Pipeline.Workspace)/.yarn

  ${{ if eq(parameters['ENV'], 'dev') }}:
    AZURE_SUBSCRIPTION: $(DEV_AZURE_SUBSCRIPTION)
    RESOURCE_GROUP: $(DEV_WEB_APP_RESOURCE_GROUP_NAME)
    APP_NAME: $(DEV_WEB_APP_NAME)
    STAGE: "d"
    dockerRegistryServiceConnection: $(DEV_CONTAINER_REGISTRY)
    dockerNamespace: $(DEV_CONTAINER_NAMESPACE)

  ${{ if eq(parameters['ENV'], 'uat') }}:
    AZURE_SUBSCRIPTION: $(UAT_AZURE_SUBSCRIPTION)
    RESOURCE_GROUP: $(UAT_WEB_APP_RESOURCE_GROUP_NAME)
    APP_NAME: $(UAT_WEB_APP_NAME)
    STAGE: "u"
    dockerRegistryServiceConnection: $(UAT_CONTAINER_REGISTRY)
    dockerNamespace: $(UAT_CONTAINER_NAMESPACE)

  ${{ if eq(parameters['ENV'], 'prod') }}:
    AZURE_SUBSCRIPTION: $(PROD_AZURE_SUBSCRIPTION)
    RESOURCE_GROUP: $(PROD_WEB_APP_RESOURCE_GROUP_NAME)
    APP_NAME: $(PROD_WEB_APP_NAME)
    STAGE: "p"
    dockerRegistryServiceConnection: $(PROD_CONTAINER_REGISTRY)
    dockerNamespace: $(PROD_CONTAINER_NAMESPACE)

  ${{ if eq(variables['Build.SourceBranchName'], 'merge') }}:
    SOURCE_BRANCH: "main" # force to main branch
  ${{ if ne(variables['Build.SourceBranchName'], 'merge') }}:
    SOURCE_BRANCH: ${{ variables['Build.SourceBranchName'] }}

  title: ""
  sha: ""
  tag: ""
  version: ""

# Only manual triggers
trigger: none
pr: none

pool:
  vmImage: ubuntu-latest

resources:
  repositories:
    - repository: pagopaCommons
      type: github
      name: pagopa/azure-pipeline-templates
      ref: refs/tags/v18
      endpoint: 'io-azure-devops-github-ro'

stages:

  # Create a release on GitHub
  - stage: release_service
    # bump version if SEMVER is not 'skip'
    condition: ne('${{ parameters.SEMVER }}', 'skip')
    pool:
      vmImage: "ubuntu-latest"
    jobs:
      - job: releaseService
        steps:
          - template: templates/node-job-setup/template.yaml@pagopaCommons
            parameters:
              persistCredentials: true
              gitReference: $(SOURCE_BRANCH)

          - template: azure-templates/node-versioning.yml
            parameters:
              semver: '${{ parameters.SEMVER }}'
              release_branch: $(SOURCE_BRANCH)
              gitEmail: $(GIT_EMAIL)
              gitUsername: $(GIT_USERNAME)
              gitHubConnection: $(GITHUB_CONNECTION)

          - script: |
              echo $(tag)
              echo $(title)
              echo $(sha)


  # Prepare Artifact with application bundle
  - stage: prepare_artifact
    condition: not(failed('release_service'))
    pool:
      vmImage: 'ubuntu-latest'
    jobs:
      - job: 'make_build'
        steps:
          # Build application
          - template: templates/node-job-setup/template.yaml@pagopaCommons
            parameters:
              # On the assumption that this stage is executed only when Release stage is,
              #  with this parameter we set the reference the deploy script must pull changes from.
              # The branch/tag name is calculated from the source branch
              #  ex: Build.SourceBranch=refs/heads/master --> master
              #  ex: Build.SourceBranch=refs/tags/v1.2.3-RELEASE --> v1.2.3-RELEASE
              gitReference: ${{ replace(replace(variables['Build.SourceBranch'], 'refs/tags/', ''), 'refs/heads/', '') }}

          - script: yarn test
            displayName: 'Test'

          - script: yarn build
            displayName: 'Build'

          - script: |
              VERSION=$(node -p "require('./package.json').version")
              echo "##vso[task.setvariable variable=version]VERSION"
            displayName: 'Get Version'

          - task: Docker@2
            displayName: Build and push an image to container registry
            inputs:
              containerRegistry: '$(dockerRegistryServiceConnection)'
              repository: '$(IMAGE_REPOSITORY)'
              command: 'buildAndPush'
              tags: |
                $(Build.BuildId)
                latest
                $(version)

  # Deploy on K8s with Helm
  - stage: 'Serving_helm'
    displayName: 'Serving_Helm'
    dependsOn: prepare_artifact
    condition: or(succeeded(), ne('${{ parameters.SEMVER }}', 'skip') )
    jobs:
      - job: Serving_helm
        displayName: Serving_helm
        steps:
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Artifact manifests'
            condition: succeeded()
            inputs:
              targetPath: '$(Build.Repository.LocalPath)/helm'
              artifact: 'helm'
              publishLocation: 'pipeline'

  - stage: 'Deploy'
    displayName: 'Deploy_to_${{ parameters.ENV }}'
    dependsOn: "Serving_helm"
    condition: or(succeeded(), ne('${{ parameters.SEMVER }}', 'skip') )
    jobs:
      - deployment: 'Deploy_to_${{ parameters.ENV }}'
        displayName: 'Deploy_to_${{ parameters.ENV }}'
        environment: '${{ parameters.ENV }}'
        strategy:
          runOnce:
            deploy:
              steps:
                - download: none
                - task: DownloadPipelineArtifact@2
                  inputs:
                    buildType: 'current'
                    artifactName: 'helm'
                    targetPath: '$(Pipeline.Workspace)/helm'
                - task: Bash@3
                  name: helm_dependency_build
                  displayName: Helm dependency build
                  inputs:
                    workingDirectory: '$(Pipeline.Workspace)/helm'
                    targetType: 'inline'
                    script: |
                      helm repo add pagopa-microservice https://pagopa.github.io/aks-microservice-chart-blueprint
                      helm dep build
                    failOnStderr: true
                - task: HelmDeploy@0
                  displayName: Helm upgrade
                  inputs:
                    kubernetesServiceEndpoint: ${{ variables.kubernetesServiceConnection }}
                    namespace: '$(nameSpace)'
                    command: upgrade
                    chartType: filepath
                    chartPath: $(Pipeline.Workspace)/helm
                    chartName: $(imageRepository)
                    releaseName: $(imageRepository)
                    valueFile: "$(Pipeline.Workspace)/helm/values-${{ parameters.ENV }}.yaml"
                    install: true
                    waitForExecution: true
                    arguments: "--timeout 5m0s"
